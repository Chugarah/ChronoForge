using System.Data.Common;
using System.Net;
using Core.DTOs.Associations;
using Core.DTOs.Project;
using Core.DTOs.ServicesContracts;
using Core.Interfaces.Associations;
using Core.Interfaces.Data;
using Core.Interfaces.DTos;
using Domain;

namespace Core.Services;

/// <summary>
/// Summary Generated by AI Phind
/// Provides transactional management of project-service contract associations
/// using Unit of Work and Repository patterns.
/// <para>
/// Handles core business logic for:
/// - Service contract attachment/detachment to projects
/// - Association state validation
/// - Transactional integrity
/// - Error recovery
/// </para>
/// </summary>
/// <remarks>
/// <para>Dependencies:</para>
/// <list type="bullet">
/// <item><see cref="IProjectRepository"/> - Project data persistence</item>
/// <item><see cref="IServiceContractsRepository"/> - Service contract management</item>
/// <item><see cref="IUnitOfWork"/> - Transaction coordination</item>
/// </list>
/// </remarks>
public class ProjectAssociationService(
    // Repositories
    IProjectRepository projectRepository,
    IServiceContractsRepository serviceContractsRepository,
    // Factories
    IAssociationFactory associationFactory,
    IProjectDtoFactory projectDtoFactory,
    IServiceContractsServiceDtoFactory serviceContractsServiceDtoFactory,
    // Utilities
    IUnitOfWork unitOfWork
) : IProjectAssociationService
{
    /// <summary>
    /// Generated by AI Phind Summary
    /// https://learn.microsoft.com/en-us/ef/core/change-tracking/debug-views
    /// Associates a service contract with a project using ACID-compliant transaction
    /// </summary>


    public async Task<AssociationFullResultDto> AttachServiceContractToProjectAsync(
        ProjectInsertFormDto projectInsertFormDto,
        ServiceContractsInsertDto serviceContractsInsertDto
    )
    {
        #region BEGIN TRANSACTION

        // Begin Transaction to ensure that all operations are successful
        await unitOfWork.BeginTransactionAsync();

        try
        {
            var project = projectDtoFactory.ToDomainProjectInsert(projectInsertFormDto);
            var serviceContracts = serviceContractsServiceDtoFactory.ToDomainServiceContractsInsert(
                serviceContractsInsertDto
            );

            // Lets save changes for both project and service contracts
            var createdProject = await projectRepository.CreateAsync(project);
            var createdServiceContracts = await serviceContractsRepository.CreateAsync(
                serviceContracts
            );
            await unitOfWork.SaveChangesAsync<object>();


            // Check if the project already has the service contract associated
            // If it does, return a conflict result
            if (createdServiceContracts != null)
            {
                // Populate the project with the service contract
                // using factory pattern DTO construction
                var updatedAssociationDto = new AssociationFullInsertDto
                {
                    // Populate the project with the service contract
                    ProjectInsertFormDto = new ProjectInsertFormDto
                    {
                        Title = createdProject.Title,
                        ProjectManager = createdProject.ProjectManager,
                        StartDate = createdProject.StartDate,
                        EndDate = createdProject.EndDate,
                        StatusId = createdProject.StatusId,
                        Description = createdProject.Description
                    },
                    ServiceContractsInsertDto = new ServiceContractsInsertDto
                    {
                        CustomerId = createdServiceContracts.CustomerId,
                        PaymentTypeId = createdServiceContracts.PaymentTypeId,
                        Name = createdServiceContracts.Name,
                        Price = createdServiceContracts.Price
                    }
                };
            }

            // Save the changes to the database
            await unitOfWork.SaveChangesAsync<object>();
            await unitOfWork.CommitTransactionAsync();

            return BuildSuccessResult(project, serviceContracts);
        }
        catch (Exception ex)
        {
            await unitOfWork.RollbackTransactionAsync();
            return BuildErrorResult(ex);
        }

        #endregion END TRANSACTION
    }

    /// <summary>
    /// Generated by AI Phind Summary
    /// Disassociates a service contract from a project with ACID-compliant transaction safety
    /// </summary>
    /// <param name="projectId">Target project ID</param>
    /// <param name="serviceContractId">Service contract ID to disassociate</param>
    /// <returns>
    /// <see cref="AssociationResultDto"/> containing:
    /// <list type="bullet">
    /// <item>Success status</item>
    /// <item>Operation message</item>
    /// <item>Project ID reference</item>
    /// <item>Service Contract ID reference</item>
    /// </list>
    /// </returns>
    /// <remarks>
    /// Implements full disassociation lifecycle management:
    /// 1. Project existence validation
    /// 2. Association existence verification
    /// 3. Transactional integrity
    /// 4. Factory-pattern DTO construction
    ///
    /// Follows same repository pattern as <see cref="AttachServiceContractToProjectAsync"/>
    /// and uses <see cref="BaseRepository{TDomain,TEntity}"/> update operations
    /// </remarks>
    /// <example>
    /// Typical success response:
    /// <code>
    /// {
    ///     Success: true,
    ///     Message: "Service contract detached successfully",
    ///     ProjectId: 123,
    ///     ServiceContractId: 456
    /// }
    /// </code>
    /// </example>
    public async Task<AssociationResultDto> DetachServiceContractFromProjectAsync(
        int projectId,
        int serviceContractId
    )
    {
        try
        {
            // Getting a project from the database
            var project = await projectRepository.GetAsync(
                p => p != null && p.Id == projectId,
                true
            );

            // Check if the project exists
            if (project == null)
            {
                // Return the result of the operation using the factory to create the DTO
                return associationFactory.AssociationResultDto(
                    false,
                    message: "Project not found",
                    HttpStatusCode.NotFound
                );
            }

            // Get the service contract to remove
            var serviceToRemove = project.ServiceContracts.FirstOrDefault(s =>
                s != null && s.Id == serviceContractId
            );

            #region BEGIN TRANSACTION
            // Begin Transaction to ensure that all operations are successful
            await unitOfWork.BeginTransactionAsync();
            // Proceed to remove the service contract from the project
            project.ServiceContracts.Remove(serviceToRemove);
            // Save the changes to the database
            await unitOfWork.SaveChangesAsync<object>();
            // Commit the transaction to ensure that all operations are successful
            await unitOfWork.CommitTransactionAsync();
            #endregion END TRANSACTION

            // Return the result of the operation using the factory to create the DTO
            return associationFactory.AssociationResultDto(
                true,
                "Service contract detached successfully",
                HttpStatusCode.OK
            );
        }
        catch (DbException ex)
        {
            // Rollback the transaction if an error occurs
            await unitOfWork.RollbackTransactionAsync();
            // Throw an exception if the database operation fails
            throw new Exception("Database operation failed during detachment", ex);
        }
    }

    /// <summary>
    /// Summary Generated by AI Phind
    /// Retrieves all service contracts associated with a specified project
    /// </summary>
    /// <param name="projectId">Target project ID</param>
    /// <returns>
    /// Enumerable of <see cref="ServiceContracts"/> or empty collection if:
    /// <list type="bullet">
    /// <item>Project has no associations</item>
    /// <item>Project doesn't exist</item>
    /// </list>
    /// </returns>
    public async Task<IEnumerable<ServiceContracts?>> GetServiceContractsForProjectAsync(
        int projectId
    )
    {
        // Get a project with included services
        var project = await projectRepository.GetAsync(
            p => p != null && p.Id == projectId,
            false,
            p => p.ServiceContracts
        );

        // Return the services for the project
        return project?.ServiceContracts! ?? Enumerable.Empty<ServiceContracts>();
    }

    private AssociationFullResultDto BuildErrorResult(Exception ex)
    {
        return associationFactory.AssociationFullResultDto(
            null,
            null,
            associationFactory.AssociationResultDto(
                false,
                $"Operation failed: {ex.Message}",
                HttpStatusCode.InternalServerError
            )
        );
    }

    // While we're here, let's add the other builder methods for completeness
    private AssociationFullResultDto BuildSuccessResult(Projects project, ServiceContracts contract)
    {
        return associationFactory.AssociationFullResultDto(
            projectDtoFactory.ToDtoProjectShow(project),
            serviceContractsServiceDtoFactory.ToDtoServiceContractDisplay(contract),
            associationFactory.AssociationResultDto(
                true,
                "Association created successfully",
                HttpStatusCode.Created
            )
        );
    }

    private AssociationFullResultDto BuildConflictResult(
        Projects project,
        ServiceContracts contract
    )
    {
        return associationFactory.AssociationFullResultDto(
            projectDtoFactory.ToDtoProjectShow(project),
            serviceContractsServiceDtoFactory.ToDtoServiceContractDisplay(contract),
            associationFactory.AssociationResultDto(
                false,
                "Service contract already associated",
                HttpStatusCode.Conflict
            )
        );
    }
}
